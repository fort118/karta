/**
 * Takes a class for an extended Component/HTMLElement
 * and registes it basedof the ClassName as class-name.
 *
 * @param {CustomElementConstructor} classInstace Instance of a custom element to register
 * @param {{ name: ?string }} options
 * @returns {string} the kebab-case version fo ClassName
 */
export default function registerComponent(classInstace: CustomElementConstructor, { name }?: {
    name: string | null;
}): string;
export class Component extends HTMLElement {
    constructor(componentPath: any);
    componentPath: any;
    $(q: any): any;
    get cssPath(): any;
    get htmlPath(): any;
    get props(): any;
    /**
     * Fetch sibling CSS if componentPath was sent in the super call.
     * Execute the render method of the component and return the result as a node
     *
     * @returns {Promise<DocumentFragment>}
     */
    _render(): Promise<DocumentFragment>;
    fetchHTMLAsDocFrag(): Promise<DocumentFragment>;
    fetchCSSAsStyleSheet(): Promise<CSSStyleSheet>;
    /**
     * Fetch sibling CSS and HTML if componentPath was sent in the super call.
     * If these has already been fetched (a component is initied more than one)
     * then re-use the cached document fragment instead of fethcing again.
     *
     * @returns {Promise<Node>}
     */
    _renderHTMLFile(): Promise<Node>;
    componentDidMount(): void;
    connectedCallback(): Promise<void>;
    _sDOM: ShadowRoot;
}
